\chapter{Nuts and bolts}
Before starting with the book's topic I want to explain how to set up an
efficient environment and some good practice which can improve the code's readability and quality.
As somebody will notice these methods are completely opposite to the general code style trends. I'll 
try to give the motivation for each rule. Anyway, in general because the SQL universe is a strange 
place this requires strange approach. In order to write and read effectively the SQL the coder should gain 
the capability to get a mental map  between the query's sections and the underlying logic. This can be 
facilitated using a clear and well defined formatting.\newline

\section{Code formatting}
The SQL language is based on statements. Each statement is terminated by a specific character, by default ``;'' . 
In order to understand the logic of the SQL statements is very important to get the statements formatted in the same 
way the database executes them. We'll look first how to format the SELECT, then the DML and finally the DDL. Each of 
those queries needs a different structure because of the different logic. The common formatting rules are the following.

\begin{itemize}
 \item There is a tab separator of 7 spaces
 \item All the keywords are in upper case
 \item After a round bracket there is a carriage return and one tab indented 
 \item The opening and closing round brackets are indented at the same level
\end{itemize}

We'll take a look to the SELECT, the DML and the DDL. We'll define the procedural language formatting in part 
\ref{part:plang}


\subsection{SELECT}
\label{sub:FRMSELECT}
When processing a query the parser works backward. It starts from the innermost and lowest complete statements and 
moves upward in order to get the entire picture. There is one remarkable exception. The WITH statements are computed 
first because required in the rest of the query. Actually the WITH acts like a temporary table. In order to see 
immediately the way PostgreSQL processes the query the indention should follow the same logic. \newline


\subsubsection{General formatting}

The following rules define the general shape of a SELECT statement. 
\begin{itemize}
 \item After the word SELECT there is a carriage return
 \item The columns are separated by a comma and a carriage return
 \item The columns indent one tab from the respective SELECT
 \item The word FROM indents at the same level of SELECT 
 \item The relation indent one tab from the word FROM
 \item The word WHERE indents at the same level of SELECT and FROM
 \item A single condition indents one tab from the WHERE 
 \item Multiple conditions indent two tabs from the where and the logical operators indent one tab from the where
 \item Between the logical operators and the condition there is one tab
 \item GROUP BY and ORDER BY follow the same rules of the select list
 \item The queries joined by UNION, INTERSECT, and EXCEPT indent one tab 
 \item The terminator character indents at the same level of the SELECT,FROM and WHERE
\end{itemize}

Let's format a simple select from one relation and with one or more condition in the where section.

\begin{lstlisting}[style=pgsql]
 select v_field1,i_field2,i_field3 from t_table1 where i_field2=125;
\end{lstlisting}

The first thing to do is to change all the keywords in upper case.

\begin{lstlisting}[style=pgsql]
 SELECT v_field1,i_field2,i_field3 FROM t_table1 WHERE i_field2=125;
\end{lstlisting}

We'll then format the select list.

\begin{lstlisting}[style=pgsql]
SELECT 
	v_field1,
	i_field2,
	i_field3 
FROM t_table1 WHERE i_field2=125;
\end{lstlisting}

Finally the from and the where.

\begin{lstlisting}[style=pgsql]
SELECT 
	v_field1,
	i_field2,
	i_field3 
FROM 
	t_table1 
WHERE 
	i_field2=125
;
\end{lstlisting}


Having multiple conditions requires an extra tab in order to keep aligned the logical operators and the 
conditions.

\begin{lstlisting}[style=pgsql]
SELECT 
	v_field1,
	i_field2,
	i_field3 
FROM 
	t_table1 
WHERE 
		i_field2=125
	AND	i_field3=440
;
\end{lstlisting}


\subsubsection{Joins}

\begin{itemize}
 \item If using the implicit joins the relations are separated by a comma and a carriage return, and indented at 
the same level
 \item When using explicit joins specify the kind of join [INNER,LEFT OUTER,CROSS etc.] 
 \item After the left hand relation there is a carriage return
 \item The join clause indents at the same level of the left hand relation
 \item After the words [INNER,LEFT OUTER,CROSS] JOIN follows the relation's name and a carriage return
 \item The word ON indents one tab from the JOIN and there is a carriage return
 \item The join conditions follow the same rules of the WHERE condition
 \item Nested joins indent one tab from the upper join
 \item The usage of the aliases, with the optional word AS is strongly encouraged
 \end{itemize}
\pagebreak
Query with implicit join
\begin{lstlisting}[style=pgsql]
SELECT 
	t1.v_field1,
	t1.i_field2,
	t2.i_field3 
FROM 
	t_table1 t1,
	t_table2 t2
WHERE 
		t1.i_field2=125
	AND	t1.i_field3=440
	AND	t1.v_field1=t2.v_field2
;
\end{lstlisting}


Query with explicit inner join
\begin{lstlisting}[style=pgsql]
SELECT 
	t1.v_field1,
	t1.i_field2,
	t2.i_field3 
FROM 
	t_table1 t1 
	INNER JOIN t_table2 t2
		ON
			t1.v_field1=t2.v_field2
WHERE 
		t1.i_field2=125
	AND	t1.i_field3=440
;
\end{lstlisting}

Query with explicit inner join and a nested join
\begin{lstlisting}[style=pgsql]
SELECT 
	t1.v_field1,
	t1.i_field2,
	t2.i_field3 
FROM 
	t_table1 t1 
	INNER JOIN t_table2 t2
		LEFT OUTER JOIN t_table3 t3
			ON
				t3.i_field1=t2.i_field1
		ON
			t1.v_field1=t2.v_field2
WHERE 
		t1.i_field2=125
	AND	t1.i_field3=440
;
\end{lstlisting}
\subsubsection{Subqueries}

\begin{itemize}
 \item All the subqueries will indent one tab from the surrounding brackets
 \item If the subquery is short in can stay in line with the round brackets (e.g. SELECT now())
\end{itemize}


Query with subselect in the SELECT's list
\begin{lstlisting}[style=pgsql]
SELECT 
	t1.v_field1,
	t1.i_field2,
	t2.i_field3,
	(
		SELECT 
			i_field2
		FROM
			t_table4 t4
		WHERE
			t4.v_field1=t2.v_field1
	) AS i_field4
FROM 
	t_table1 t1 
	INNER JOIN t_table2 t2
		LEFT OUTER JOIN t_table3 t3
			ON
				t3.i_field1=t2.i_field1
		ON
			t1.v_field1=t2.v_field2
WHERE 
		t1.i_field2=125
	AND	t1.i_field3=440
;
\end{lstlisting}

Query with subselect in the FROM's list
\begin{lstlisting}[style=pgsql]
SELECT 
	t1.v_field1,
	t1.i_field2,
	t2.i_field3,
	t4.i_field4
FROM 
	t_table1 t1 
	INNER JOIN t_table2 t2
		LEFT OUTER JOIN t_table3 t3
			ON
				t3.i_field1=t2.i_field1
		ON
			t1.v_field1=t2.v_field2
	INNER JOIN 	(
				SELECT 
					i_field2,
					v_field1
				FROM
					t_table4 t4
			) t4
		ON
			t4.v_field1=t2.v_field1
WHERE 
		t1.i_field2=125
	AND	t1.i_field3=440
;
\end{lstlisting}


\subsubsection{WITH statements}
Because the WITH statement works like having a temporary table, the formatting will follow rules similar to the 
CREATE TABLE statement.

\begin{itemize}
 \item Between the WITH and the alias there is a tab followed by the word AS and a carriage return
 \item The  round brackets surrounding the inner query indent one tab from the alias
 \item The inner query indents one tab from the round brackets
\end{itemize}




\begin{lstlisting}[style=pgsql]
WITH	t_sub1 AS
		(
			SELECT 
				t1.v_field1,
				t1.i_field2,
				t2.i_field3,
				t4.i_field4
			FROM 
				t_table1 t1 
				INNER JOIN t_table2 t2
					LEFT OUTER JOIN t_table3 t3
						ON
							t3.i_field1=t2.i_field1
					ON
						t1.v_field1=t2.v_field2
				INNER JOIN 	(
							SELECT 
								i_field2,
								v_field1
							FROM
								t_table4 t4
						) t4
					ON
						t4.v_field1=t2.v_field1
			WHERE 
					t1.i_field2=125
				AND	t1.i_field3=440
		
		),
	t_sub1 AS
		(
			SELECT
				t5.v_field1,
				t5.i_field2
			FROM
				t_table5 t5
			WHERE 
				t5.i_field1=42
		
		)
SELECT 
	t_sub1.v_field1
FROM
	t_sub1
	INNER JOIN t_sub2
		ON
			t_sub1.i_field2=t_sub2.i_field2
;
\end{lstlisting}



\subsubsection{Few final words}

This coding style is at first sight complex and with some drawback as it can slow down the coding process because 
of more keystrokes required for the uppercase and the carriage return. However, when the writing automatism is acquired 
the coding speed is very fast.\newline

This coding style creates the query using a top down structure where the different part of the query are 
indented in order to reflecting their level inside the query's logic. This increases the query readability in 
particular when dealing with complex queries. The vertical block structure gives great control on the query's sub 
sections. With query editors supporting the partial code execution  (e.g. pgadmin3's query ) is possible to highlight 
the query's single sections and execute them immediately. 

I developed this style from the induction I received in my first DBA job. My employer enforced along the developers and 
DBA a similar set of rules which worked perfectly, improving the productivity and the code's consistency across the 
company.\newline

Incidentally this matches almost perfectly the way PostgreSQL processes a select. What follow is an excerpt of the 
PostgreSQL' manual describing how the select is processed.

\begin{smallverbatim}
 

SELECT retrieves rows from zero or more tables. The general processing of SELECT is as follows:

1. All queries in the WITH list are computed. 
These effectively serve as temporary tables that can be referenced in the FROM list. 
A WITH query that is referenced more than once in FROM is computed only once. 


2. All elements in the FROM list are computed. 
(Each element in the FROM list is a real or virtual table.) 
If more than one element is specified in the FROM list, they are cross-joined together.


3. If the WHERE clause is specified, all rows that do not satisfy the condition 
are eliminated from the output. 


4. If the GROUP BY clause is specified, or if there are aggregate function calls, 
the output is combined into groups of rows that match on one or more values, 
and the results of aggregate functions are computed. 
If the HAVING clause is present, it eliminates groups that do not satisfy the 
given condition. 


5. The actual output rows are computed using the SELECT output expressions 
for each selected row or row group. 


6. SELECT DISTINCT eliminates duplicate rows from the result. 
SELECT DISTINCT ON eliminates rows that match on all the specified expressions. 
SELECT ALL (the default) will return all candidate rows, including duplicates. 


7. Using the operators UNION, INTERSECT, and EXCEPT, the output of more than one 
SELECT statement can be combined to form a single result set. 
The UNION operator returns all rows that are in one or both of the result sets. 
The INTERSECT operator returns all rows that are strictly in both result sets. 
The EXCEPT operator returns the rows that are in the first result set but not in the second. 
In all three cases, duplicate rows are eliminated unless ALL is specified. 
The noise word DISTINCT can be added to explicitly specify eliminating duplicate rows. 
Notice that DISTINCT is the default behavior here, even though ALL is the default for SELECT itself. 


8. If the ORDER BY clause is specified, the returned rows are sorted in the specified order. 
If ORDER BY is not given, the rows are returned in whatever order the system finds fastest to produce. 


9. If the LIMIT (or FETCH FIRST) or OFFSET clause is specified, the SELECT statement only returns 
a subset of the result rows. 

10. If FOR UPDATE, FOR NO KEY UPDATE, FOR SHARE or FOR KEY SHARE is specified, 
the SELECT statement locks the selected rows against concurrent updates. 

\end{smallverbatim}



\subsection{INSERT}
The INSERT statement is composed by two elements, the attribute list and the values list. The lists are positional.
The formatting should mark clearly the various elements of the query in order to make it simpler to spot the 
correspondence between the attribute and the value. 

\begin{itemize}
 \item After the words INSERT INTO there is one space followed by the table's name
 \item After the table's name there is one carriage return
 \item The attributes if present are enclosed between round brackets indented one tab from the word INSERT
 \item The attribute's list indents one tab from the round brackets
 \item The attributes indent one tab fro the round brackets and are separated by a carriage return
 \item The word VALUES indents at the same level of INSERT and is followed by a carriage return
 \item The value's list is surrounded by round brackets indented one tab from the  word VALUE
 \item The values indent one tab fro the round brackets and are separated by a carriage return
\end{itemize}
\newpage

\begin{lstlisting}[style=pgsql]

INSERT INTO t_table
VALUES
	(
		'test',
		'test2',
		'this is a test',
		42
	)
;


INSERT INTO t_table
	(
		v_field1,
		v_field2,
		t_field3
		i_field4
	)
VALUES
	(
		'test',
		'test2',
		'this is a test',
		42
	)
;

\end{lstlisting}

\subsection{UPDATE}
The WHERE condition on the update is the same of the SELECT. Take a look to \ref{sub:FRMSELECT} for more 
informations. Just after the table's name there is the keyword SET and the list of the updates. The 
formatting should reflect this particular structure.

\begin{itemize}
 \item After the table's name there is one carriage return
 \item The word SET indents one tab from the word UPDATE
 \item The update's list indents one tab from the word set
 \item Each update is separated by a carriage return
\end{itemize}


\begin{lstlisting}[style=pgsql]

UPDATE t_table
	SET
		v_field1='test',
		v_field2'test2',
		t_field3='this is a test',
		i_field4=42
WHERE
	i_field5=33
;

\end{lstlisting}



\subsection{DELETE}
The delete is the simplest of the DML as lists just the target relation and the eventual WHERE condition.
The formatting is quite simple as the where condition is the only part which requires to be structured as seen in 
\ref{sub:FRMSELECT}.

\begin{lstlisting}[style=pgsql]
DELETE FROM t_table
WHERE
	i_field5=33
;
\end{lstlisting}


As said before the DML queries have a different logic so they require a different formatting style. 

\subsection{Data Definition Language}

\section{Type based field name}
Debugging a query is not a simple task. Mostly because there is no debugger. Any little bit of clarity when 
designing the schema is a massive help for this difficult task. Adding a simple prefix to the field's name have a  
beneficial effect in making clear which data type is stored inside the column. Obiously having a design diagram or 
a data dictionary can help but they can be outdated or maybe are not generally accessible.\newline 

This convention have another great advantage. 

\begin{table}[H]
\begin{tabular}{ll}
 \textbf{Object} & \textbf{Prefix}  \\
 \hline
 Table & t\_ \\
 View & v\_ \\
Btree Index & idx\_bt\_ \\
GiST Index & idx\_gst\_ \\
GIN Index & idx\_gin\_ \\
Unique index & u\_idx\_ \\
Primary key & pk\_ \\
Foreign key & fk\_ \\
Check & chk\_ \\
Unique key & uk\_ \\
Type & ty\_ \\
Sql function & fn\_sql\_ \\
PlPgsql function & fn\_plpg\_ \\
PlPython function & fn\_plpy\_ \\
PlPerl function & fn\_plpr\_ \\
Trigger & trg\_ \\
rule & rul\_ \\

\end{tabular}
\end{table}

A similar approach can be used for the column names, making the data type immediately recognisable.

\begin{table}[H]
\begin{tabular}{ll}
 \textbf{Type} & \textbf{Prefix}  \\
 \hline
 Character & c\_ \\
 Character varying & v\_ \\
Integer & i\_ \\
Text & t\_ \\
Bytea & by\_ \\
Numeric & n\_ \\
Timestamp & ts\_ \\
Date & d\_ \\
Double precision & dp\_ \\
Hstore & hs\_ \\
Custom data type & ty\_ \\

\end{tabular}
\end{table}



\section{The editor}
Unlikely many commercial RDBMS PostgreSQL, ships only with the command line client psql. There is a 
good quantity of third party clients with good support for the database features and a good connectivity 
layer. An exhaustive list of those clients can be found on the PostgreSQL wiki\newline
\href{https://wiki.postgresql.org/wiki/Community\_Guide\_to\_PostgreSQL\_GUI\_Tools}{
https://wiki.postgresql.org/wiki/Community\_Guide\_to\_PostgreSQL\_GUI\_Tools}. Is difficult to say 
which editor is the best. When I started learning PostgreSQL the only tool available were PGAdmin 2 and 
phpPgAdmin. I decided for the former and I welcomed the newer version PgAdmin 3. However I tested some of 
the other clients like TOra, SQL workbench and SQL Maestro and I never found the same confidence and ease 
of usage like PgAdmin 3. Whether is the tool of your choice this should have the following features.

\subsection{Native connector}
One of the reasons I do not like SQL workbench is the JDBC connector. For me writing and testing the SQL 
code is a quick process. I write the code which is run against the database, then I update the query, 
another run and so on. The client response in this method is absolutely important. The native connector 
have virtually no lag, except the disk/network bandwidth.

\subsection{Removal of the Byte Order Mark (BOM)} 


\section{wrap up}
